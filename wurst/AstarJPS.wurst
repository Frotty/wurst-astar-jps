package AstarJPS
import ClosureTimers
import Execute
import TerrainUtils
import SearchNode
import OpenSet
import ClosedSet
import HashMap
import HashSet
import ErrorHandling
import Abilities

public constant GRID_SIZE = 64.
public constant GRID_SIZE_I = GRID_SIZE.toInt()

public class GoalNode implements Hashable
    vec2 t

    construct(vec2 t)
        this.t = t

    function inGoal(SearchNode other) returns boolean
        return t.distanceTo(other.t) < GRID_SIZE * 2 + 1

    override function hash() returns int
        return (t.x * GRID_SIZE + t.y).toInt()

public tuple astarResult(bool success, HashList<SearchNode> nodes)

public abstract class PathingCondition
    protected abstract function isPathable(vec2 test) returns bool

public abstract class OnPathFound
    protected abstract function call(astarResult res)

function vec2.manhattan_to(vec2 rhs) returns real
    return (this.x - rhs.x).abs() + (this.y - rhs.y).abs()

public class Pathfinder
    private let allNodes = new IterableMap<real, SearchNode>
    private var done = false
    private var inSubStep = 0

    private var start = ZERO2
    private GoalNode target = null
    private PathingCondition cond = null
    private OpenSet openSet = null
    private ClosedSet closedSet = null

    var outputPath = false
    var debug = false
    var stepDelay = 0.1

    SearchNode lastJumpPoint = null

    construct(vec2 start, vec2 target)
        this.start = normalizePosition(start)
        this.target = new GoalNode(normalizePosition(target))

    function normalizePosition(vec2 pos) returns vec2
        var result = ZERO2
        result.x = (pos.x / GRID_SIZE).round() * GRID_SIZE
        if pos.x < 0
            result.x += GRID_SIZE / 2
        else
            result.x -= GRID_SIZE / 2
        result.y = (pos.y / GRID_SIZE).round() * GRID_SIZE
        if pos.y < 0
            result.y += GRID_SIZE / 2
        else
            result.y -= GRID_SIZE / 2
        return result

    function setCond(PathingCondition pred)
        this.cond = pred

    function search(OnPathFound onFinish)
        if cond == null
            error("Pathing condition may not be null")

        openSet = new OpenSet()
        openSet.add(getNode(this.start, null)..setOpen())

        closedSet = new ClosedSet()

        doPeriodically(stepDelay) cb ->
            if openSet.is_empty() and inSubStep == 0
                done = true
                execute() ->
                    for key in allNodes
                        let node = allNodes.get(key)
                        if node != null
                            destroy node

                onFinish.call(astarResult(false, null))
                destroy cb
                destroy this

            else if inSubStep == 0
                lastJumpPoint = openSet.poll()

                lastJumpPoint.setActive()
                if target.inGoal(lastJumpPoint)
                    lastJumpPoint.setFinish()
                    done = true
                    var result = new HashList<SearchNode>
                    if outputPath
                        result = backtrace(lastJumpPoint)
                    execute() ->
                        for key in allNodes
                            let node = allNodes.get(key)
                            if node != null and not result.has(node)
                                destroy node
                    destroy cb
                    onFinish.call(astarResult(true, result))
                    destroy this
                else
                    identifySuccessors(lastJumpPoint)

                    closedSet.add(lastJumpPoint)
                    lastJumpPoint.setClosed()

    private function getNode(vec2 t, SearchNode parent) returns SearchNode
        let hash = t.x * GRID_SIZE + t.y
        if not allNodes.has(hash)
            allNodes.put(hash, new SearchNode(t, parent, debug))

        return allNodes.get(hash)

    private function backtrace(SearchNode theNode) returns HashList<SearchNode>
        let list = new HashList<SearchNode>
        var parent = theNode
        while parent != null
            list.add(parent)
            parent.setFinish()
            parent = parent.parent
        return list

    private function identifySuccessors(SearchNode currentNode)
        let pathing_top = getNode(currentNode.t + vec2(0, GRID_SIZE), currentNode).t.isTerrainWalkable()
        let pathing_bot = getNode(currentNode.t + vec2(0, -GRID_SIZE), currentNode).t.isTerrainWalkable()
        let pathing_left = getNode(currentNode.t + vec2(-GRID_SIZE, 0), currentNode).t.isTerrainWalkable()
        let pathing_right = getNode(currentNode.t + vec2(GRID_SIZE, 0), currentNode).t.isTerrainWalkable()

        inSubStep = 4
        doAfter(1. * stepDelay) ->
            checkCandidate(currentNode, GRID_SIZE,  0.)
            inSubStep--
        doAfter(1. * stepDelay) ->
            checkCandidate(currentNode, -GRID_SIZE,  0.)
            inSubStep--
        doAfter(1. * stepDelay) ->
            checkCandidate(currentNode, 0.,  GRID_SIZE)
            inSubStep--
        doAfter(1. * stepDelay) ->
            checkCandidate(currentNode, 0.,  -GRID_SIZE)
            inSubStep--

        if pathing_top or pathing_right
            inSubStep++
            doAfter((inSubStep - 3.) * stepDelay) ->
                checkCandidate(currentNode, GRID_SIZE,  GRID_SIZE)
                inSubStep--

        if pathing_top or pathing_left
            inSubStep++
            doAfter((inSubStep - 3.) * stepDelay) ->
                checkCandidate(currentNode, -GRID_SIZE,  GRID_SIZE)
                inSubStep--

        if pathing_bot or pathing_right
            inSubStep++
            doAfter((inSubStep - 3.) * stepDelay) ->
                checkCandidate(currentNode, GRID_SIZE,  -GRID_SIZE)
                inSubStep--

        if pathing_bot or pathing_left
            inSubStep++
            doAfter((inSubStep - 3.) * stepDelay) ->
                checkCandidate(currentNode, -GRID_SIZE,  -GRID_SIZE)
                inSubStep--


    private function checkCandidate(SearchNode currentNode, real dx, real dy)
        let candidate = getNode(currentNode.t + vec2(dx,  dy), currentNode)
        if not closedSet.has(candidate) and candidate.t.isTerrainWalkable()
            let jumpNode = jump(currentNode, dx, dy, 0)
            if jumpNode != null and openSet.getNode(jumpNode) == null and not closedSet.has(jumpNode)
                registerNode(jumpNode, lastJumpPoint)

    function registerNode(SearchNode node, SearchNode parent)
        node.parent = parent
        calculateNodeScore(node, parent)
        openSet.add(node)
        node.setOpen()

    /** JPS jump function
        Skips along in dx, dy direction until it finds a forced neighbour. */
    private function jump(SearchNode curNode, real dx, real dy, int depth) returns SearchNode
        let nextNode = getNode(curNode.t + vec2(dx, dy), curNode)
        if nextNode == null or nextNode.isPruned(dx.toInt(), dy.toInt()) or not cond.isPathable(nextNode.t)
            return null
        if target.inGoal(nextNode)
            return nextNode

        let eff = addEffect(Abilities.murgulMagicMissile, nextNode.t)
        doAfter(1.) ->
            eff.destr()

        // Diagonal
        if dx.toInt() != 0 and dy.toInt() != 0
            if (not cond.isPathable(vec2(nextNode.t.x - dx, nextNode.t.y)) and cond.isPathable(vec2(nextNode.t.x - dx, nextNode.t.y + dy))
                or not cond.isPathable(vec2(nextNode.t.x, nextNode.t.y - dy)) and cond.isPathable(vec2(nextNode.t.x + dx, nextNode.t.y - dy)))
                return nextNode

            let xjump = jump(nextNode, dx, 0, depth + 1)
            let yjump = jump(nextNode, 0, dy, depth + 1)

            if xjump != null
                registerNode(xjump, nextNode)

            if yjump != null
                registerNode(yjump, nextNode)

            if xjump != null or yjump != null
                return nextNode

        else
            // Vertical and horizontal
            if dx.toInt() != 0
                if (cond.isPathable(vec2(nextNode.t.x + dx, nextNode.t.y + GRID_SIZE)) and not cond.isPathable(vec2(nextNode.t.x, nextNode.t.y + GRID_SIZE))
                    or cond.isPathable(vec2(nextNode.t.x + dx, nextNode.t.y - GRID_SIZE)) and not cond.isPathable(vec2(nextNode.t.x, nextNode.t.y - GRID_SIZE)))
                    return nextNode
            else if dy.toInt() != 0
                if (cond.isPathable(vec2(nextNode.t.x + GRID_SIZE, nextNode.t.y + dy)) and not cond.isPathable(vec2(nextNode.t.x + GRID_SIZE, nextNode.t.y))
                    or cond.isPathable(vec2(nextNode.t.x - GRID_SIZE, nextNode.t.y + dy)) and not cond.isPathable(vec2(nextNode.t.x - GRID_SIZE, nextNode.t.y)))
                    return nextNode


        if cond.isPathable(vec2(nextNode.t.x + dx, nextNode.t.y)) or cond.isPathable(vec2(nextNode.t.x, nextNode.t.y + dy))
            nextNode.setPruned(dx.toInt(), dy.toInt())
            return jump(nextNode, dx, dy, depth + 1)
        else
            nextNode.setPruned(dx.toInt(), dy.toInt())
            return null


    private function calculateNodeScore(SearchNode node, SearchNode parent)
        let manhatten = (target.t.x - node.t.x).abs() + (target.t.y - node.t.y).abs()

        node.setH(manhatten)

        node.setG(parent.g() + calculateGScore(node, parent))

    private function calculateGScore(SearchNode newNode, SearchNode oldNode) returns int
        let manhatten = (oldNode.t.x - newNode.t.x).abs() + (oldNode.t.y - newNode.t.y).abs()
        return manhatten.toInt()

    ondestroy
        destroy allNodes
        destroy target

        destroy closedSet
        destroy openSet
